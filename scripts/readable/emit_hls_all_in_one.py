#!/usr/bin/env python3
# scripts/readable/emit_hls_all_in_one.py
import argparse, json, sys
from pathlib import Path

def slurp_json(path: Path):
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)

def ensure_list(x):
    if x is None: return []
    return x if isinstance(x, list) else [x]

def guess_name(st):
    if "name" in st and st["name"]:
        return st["name"]
    ent = st.get("entity")
    op  = st.get("op")
    if ent and op:
        return f"{op}{ent[0].upper()}{ent[1:]}"
    return "untitled"

def normalize_checks(checks):
    """
    Accepts either:
      - dict with keys preconditions/postconditions/guards
      - flat list (DET style)
    Returns dict with all three arrays.
    """
    if isinstance(checks, dict):
        return {
            "preconditions": ensure_list(checks.get("preconditions")),
            "postconditions": ensure_list(checks.get("postconditions")),
            "guards": ensure_list(checks.get("guards")),
        }
    flat = ensure_list(checks)
    pres, posts, guards = [], [], []
    for c in flat:
        cl = c.lower()
        # very light heuristics:
        if cl.startswith("verify"):
            # verifyXNotExists -> often a postcondition OR a guard;
            # keep verify* in postconditions; if contains 'not' also mirror into guards.
            posts.append(c)
            if "not" in cl or "invalid" in cl:
                guards.append(c)
        elif "valid" in cl or "not" in cl or "exists" in cl:
            guards.append(c)
        else:
            pres.append(c)
    return {"preconditions": pres, "postconditions": posts, "guards": guards}

def normalize_entities(st):
    """
    For NONDET we already have st['entities'] with {active,lifecycle,passive}.
    For DET we synthesize:
      active   := [entity] if present
      lifecycle:= st.get('blocks', [])
      passive  := (if DET had flat checks, put them here as 'passive verifications' fallback)
    """
    if isinstance(st.get("entities"), dict):
        ents = st["entities"]
        return {
            "active": ensure_list(ents.get("active")),
            "lifecycle": ensure_list(ents.get("lifecycle")),
            "passive": ensure_list(ents.get("passive")),
        }
    # DET shape
    active = [st["entity"]] if st.get("entity") else []
    lifecycle = ensure_list(st.get("blocks"))
    passive = []
    # If DET had a flat checks array, expose them also under passive so they appear in the readable.
    if isinstance(st.get("checks"), list):
        passive = list(st["checks"])
    return {"active": active, "lifecycle": lifecycle, "passive": passive}

def normalize_story(st):
    name = guess_name(st)
    entities = normalize_entities(st)
    checks = normalize_checks(st.get("checks", {}))
    steps = ensure_list(st.get("steps"))
    if not steps and st.get("entity") and st.get("op"):
        steps = [f"{st['op']}{st['entity'][0].upper()}{st['entity'][1:]}"]
    notes = ensure_list(st.get("notes"))
    return {
        "name": name,
        "entities": entities,
        "checks": checks,
        "steps": steps,
        "notes": notes,
    }

def emit_js(name: str, stories: list) -> str:
    # Minimal, UI-friendly ES module
    from json import dumps
    payload = {
        "name": name,
        "stories": stories
    }
    return (
        "// Auto-generated by emit_hls_all_in_one.py â€” DO NOT EDIT\n"
        f"export default {dumps(payload, ensure_ascii=False, indent=2)};\n"
    )

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--gold", required=True, help="Path to HLS det/nondet gold JSON")
    ap.add_argument("--out", required=True, help="Output JS file path (stories_hls.js)")
    ap.add_argument("--name", required=False, help="Logical name (e.g. sut); defaults to folder name of --out")
    args = ap.parse_args()

    gold = Path(args.gold)
    out = Path(args.out)
    out.parent.mkdir(parents=True, exist_ok=True)

    data = slurp_json(gold)
    stories_raw = data.get("stories", [])
    if not stories_raw:
        raise SystemExit(f"[ERROR] No stories in {gold}")

    stories = [normalize_story(s) for s in stories_raw]
    name = args.name or out.parent.name

    js = emit_js(name, stories)
    out.write_text(js, encoding="utf-8")
    print(f"[OK] wrote {out} ({len(stories)} stories)")

if __name__ == "__main__":
    sys.exit(main())
